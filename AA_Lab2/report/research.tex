\chapter{Исследовательский раздел}
В данном разделе представлены примеры работы программы, сравнительный анализ реализованных алгоритмов и оценка их трудоёмкости.

\section{Пример работы}

Демонстрация работы программы приведена на рисунке \ref{img:res}.

\imgsc{h}{1}{res}{Пример работы программы}

\section{Сравнительный анализ времени выполнения алгоритмов}
Чтобы провести сравнительный анализ времени выполнения алгоритмов замерялось процессорное время для квадратных матриц следующих размеров 100x100, 200x200, ... 1000x1000 и 101x101, 201x201, ... 1001x1001. Чтобы оценить время выполнения умножения матриц, они заполнялись числами от 0 до 999, замерялось процессорное время для части кода, которая умножала матрицы 10 раз, после чего результат делился на кол-во итераций.

Сравнительный анализ проводился на компьютере с процессором Intel Core i7-7700K и установленной операционной системой Windows 10.

Для алгоритма винограда наихудшим случаем является умножение матриц с нечётными размерами. Наилучшим случаем матрицы с чётными размерами. На рисунках \ref{plt:time_even} и \ref{plt:time_odd} приведены зависимости времени работы алгоритмов от нечетных и четных размеров матриц.

\begin{figure}[h]
	\begin{tikzpicture}
		\begin{axis}[
			xlabel={Линейный размер матрицы},
			ylabel={Время выполнения, сек.},
			xtick={100,200,300,400,500,600,700,800,900,1000},
			legend pos=north west,
			ymajorgrids=true,
			grid style=dashed,
			width = 400
			]
			
			\addplot[
			color=blue,
			mark=square,
			]
			coordinates {
				(100, 0.0125)(200, 0.103125)(300, 0.364583)(400, 0.882812)(500, 1.85938)(600, 3.40625)(700, 5.46875)(800, 8.15625)(900, 12)(1000, 18.4688)
			};
			\addlegendentry{standartMult() - лучший случай}
			
			
			\addplot[
			color=green,
			mark=square,
			]
			coordinates {
				(100, 0.009375)(200, 0.078125)(300, 0.265625)(400, 0.679688)(500, 1.4375)(600, 2.65625)(700, 4.40625)(800, 6.64062)(900, 9.73438)(1000, 15.6719)
			};
			\addlegendentry{vinograd() - лучший случай}
			
			\addplot[
			color=red,
			mark=square,
			]
			coordinates {
				(100, 0.009375)(200, 0.06875)(300, 0.239583)(400, 0.570312)(500, 1.19531)(600, 2.28125)(700, 3.70312)(800, 5.60938)(900, 8.15625)(1000, 12.7969)
			};
			\addlegendentry{optimizedVinograd() - лучший случай}
			
		\end{axis}
	\end{tikzpicture}
	\caption{Зависимость времени выполнения умножения матриц от их размеров в лучшем случае}
	\label{plt:time_even}
\end{figure}

\newpage
\begin{figure}
	\begin{tikzpicture}
		\begin{axis}[
			xlabel={Линейный размер матрицы},
			ylabel={Время выполнения, сек.},
			xtick={101,201,301,401,501,601,701,801,901,1001},
			legend pos=north west,
			ymajorgrids=true,
			grid style=dashed,
			width = 400
			]
			
			\addplot[
			color=blue,
			mark=square,
			]
			coordinates {
				(101, 0.0125)(201, 0.10625)(301, 0.369792)(401, 0.90625)(501, 1.90625)(601, 3.48438)(701, 5.90625)(801, 8.375)(901, 11.9688)(1001, 19.0625)
			};
			\addlegendentry{standartMult() - худший случай}
			
			
			\addplot[
			color=green,
			mark=square,
			]
			coordinates {
				(101, 0.009375)(201, 0.08125)(301, 0.276042)(401, 0.695312)(501, 1.46094)(601, 2.78125)(701, 4.34375)(801, 6.6875)(901, 9.60938)(1001, 15.8594)
			};
			\addlegendentry{vinograd() - худший случай}
			
			\addplot[
			color=red,
			mark=square,
			]
			coordinates {
				(101, 0.009375)(201, 0.075)(301, 0.260417)(401, 0.5625)(501, 1.21094)(601, 2.21875)(701, 3.625)(801, 5.5625)(901, 8.17188)(1001, 12.8125)
			};
			\addlegendentry{optimizedVinograd() - худший случай}
			
		\end{axis}
	\end{tikzpicture}
	\caption{Зависимость времени выполнения умножения матриц от их размеров в худшем случае}
	\label{plt:time_odd}
\end{figure}

\newpage
\section{Оценка трудоёмкости}
Для оценки трудоёмкости использовалась следующая модель вычислений: \cite{calc_model}
\begin{itemize}
	\item Трудоёмкость следующих операций единична: +, -, =, +=, -=, ==, !=, <, >, -=, >=, <<, >>, [];
	\item Трудоёмкость следующих операций = 2: *, /, \, \%, /=, *=.
\end{itemize}

Трудоёмкость выбранных алгоритмов сортировок рассчитывалась по написанному коду.

На листинге \ref{lst:mc_std} представлена программа для вычисления трудоёмкости классического алгоритма умножения матриц.

\newpage
\begin{lstinputlisting}[
	caption={Вычисление трудоёмкости классического алгоритма умножения матриц},
	label={lst:mc_std},
	style={c},
	linerange={1-27},
	]{./inc/src/algorithmsCalcs.cpp}
\end{lstinputlisting}

Соответственно получается следующая формула трудоёмоксти:

$FstandartMult = 3+4N+7NM+14NMK$, где N - кол-во строк первой матрицы, M - кол-во столбцов второй матрицы, K - кол-во столбцов первой матрицы

На листингах \ref{lst:mc_vinograd1}-\ref{lst:mc_vinograd1} представлена программа для вычисления трудоёмкости алгоритма Винограда.

\newpage
\begin{lstinputlisting}[
	caption={Вычисление трудоёмкости алгоритма Винограда, часть 1},
	label={lst:mc_vinograd1},
	style={c},
	linerange={29-61},
	]{./inc/src/algorithmsCalcs.cpp}
\end{lstinputlisting}

\newpage
\begin{lstinputlisting}[
	caption={Вычисление трудоёмкости алгоритма Винограда, часть 2},
	label={lst:mc_vinograd1},
	style={c},
	linerange={63-100},
	]{./inc/src/algorithmsCalcs.cpp}
\end{lstinputlisting}

Следовательно формула трудоёмкости будет следующей:

$Fvinograd = 10+10N+6M+19N(K//2)+19M(K//2)+12NM+32NM(K//2)$,  при чётном K
и такой:

$Fvinograd = 12+14N+6M+19N(K//2)+19M(K//2)+28NM+32NM(K//2)$,  при нечётном K.

На листингах \ref{lst:impс_winograd1}-\ref{lst:impс_winograd2} представлена программа для вычисления трудоёмкости оптимизированного алгоритма Винограда.

\begin{lstinputlisting}[
	caption={Вычисление трудоёмкости оптимизированного алгоритма Винограда, часть 1},
	label={lst:impс_winograd1},
	style={c},
	linerange={102-102},
	]{./inc/src/algorithmsCalcs.cpp}
\end{lstinputlisting}

\begin{lstinputlisting}[
	caption={Вычисление трудоёмкости оптимизированного алгоритма Винограда, часть 1},
	label={lst:impс_winograd1},
	style={c},
	linerange={102-102},
	]{./inc/src/algorithmsCalcs.cpp}
\end{lstinputlisting}

Формула трудоёмкости:

$Finsertion\_sort = 3 + 4*(N-1) + 8*((N-1)*N/2)$

В лучшем случае полностью пропадает тело цикла while, а значит формула изменится на следующую:

$Finsertion\_sort = 3 + 4*(N-1)$

\section{Вывод}
По итогу иследования выяснилось, что разработанная программа работает верно, то-есть сортирует массивы по возрастанию. Кроме этого, смотря на время выполнения каждого алгоритма, логично сделать вывод, что наиболее быстрым в произвольном случае, является алгоритм сортировки выбором и судя по оценке трудоёмкости, наименее трудоёмким является также алгоритм сортировки выбором.