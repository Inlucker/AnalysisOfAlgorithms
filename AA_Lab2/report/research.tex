\chapter{Исследовательский раздел}
В данном разделе представлены примеры работы программы, сравнительный анализ реализованных алгоритмов и оценка их трудоёмкости.

\section{Пример работы}

Демонстрация работы программы приведена на рисунке \ref{img:res}.

\imgsc{h}{1}{res}{Пример работы программы}

\section{Сравнительный анализ времени выполнения алгоритмов}
Чтобы провести сравнительный анализ времени выполнения алгоритмов замерялось процессорное время для квадратных матриц следующих размеров 100x100, 200x200, ... 1000x1000 и 101x101, 201x201, ... 1001x1001. Чтобы оценить время выполнения умножения матриц, они заполнялись числами от 0 до 999, замерялось процессорное время для части кода, которая умножала матрицы 10 раз, после чего результат делился на кол-во итераций.

Сравнительный анализ проводился на компьютере с процессором Intel Core i7-7700K и установленной операционной системой Windows 10.

Для алгоритма винограда наихудшим случаем является умножение матриц с нечётными размерами. Наилучшим случаем матрицы с чётными размерами. На рисунках \ref{plt:time_even} и \ref{plt:time_odd} приведены зависимости времени работы алгоритмов от нечетных и четных размеров матриц.

\begin{figure}[h]
	\begin{tikzpicture}
		\begin{axis}[
			xlabel={Линейный размер матрицы},
			ylabel={Время выполнения, сек.},
			xtick={100,200,300,400,500,600,700,800,900,1000},
			legend pos=north west,
			ymajorgrids=true,
			grid style=dashed,
			width = 400
			]
			
			\addplot[
			color=blue,
			mark=square,
			]
			coordinates {
				(100, 0.0125)(200, 0.096875)(300, 0.332813)(400, 0.810937)(500, 1.75313)(600, 3.32969)(700, 5.50625)(800, 8.20625)(900, 12.0078)(1000, 17.8375)
			};
			\addlegendentry{standartMult() - чётный размер}
			
			
			\addplot[
			color=green,
			mark=square,
			]
			coordinates {
				(100, 0.009375)(200, 0.075)(300, 0.259375)(400, 0.651563)(500, 1.38281)(600, 2.47812)(700, 4.325)(800, 6.40156)(900, 9.09375)(1000, 14.8297)
			};
			\addlegendentry{vinograd() - чётный размер}
			
			\addplot[
			color=red,
			mark=square,
			]
			coordinates {
				(100, 0.0078125)(200, 0.0609375)(300, 0.214062)(400, 0.528125)(500, 1.10781)(600, 2.07031)(700, 3.44375)(800, 5.275)(900, 7.72656)(1000, 11.7609)
			};
			\addlegendentry{optimizedVinograd() - чётный размер}
			
		\end{axis}
	\end{tikzpicture}
	\caption{Зависимость времени выполнения умножения матриц от их размеров в случае чётных размеров}
	\label{plt:time_even}
\end{figure}

\newpage
\begin{figure}
	\begin{tikzpicture}
		\begin{axis}[
			xlabel={Линейный размер матрицы},
			ylabel={Время выполнения, сек.},
			xtick={101,201,301,401,501,601,701,801,901,1001},
			legend pos=north west,
			ymajorgrids=true,
			grid style=dashed,
			width = 400
			]
			
			\addplot[
			color=blue,
			mark=square,
			]
			coordinates {
				(101, 0.0109375)(201, 0.096875)(301, 0.328125)(401, 0.821875)(501, 1.71562)(601, 3.12969)(701, 5.10469)(801, 7.69844)(901, 10.9313)(1001, 17.1453)
			};
			\addlegendentry{standartMult() - нечётный размер}
			
			
			\addplot[
			color=green,
			mark=square,
			]
			coordinates {
				(101, 0.009375)(201, 0.0734375)(301, 0.253125)(401, 0.651563)(501, 1.325)(601, 2.40469)(701, 3.99688)(801, 6.1125)(901, 8.65312)(1001, 13.8703)
			};
			\addlegendentry{vinograd() - нечётный размер}
			
			\addplot[
			color=red,
			mark=square,
			]
			coordinates {
				(101, 0.0078125)(201, 0.0640625)(301, 0.215625)(401, 0.53125)(501, 1.12656)(601, 2.04688)(701, 3.49688)(801, 5.59531)(901, 7.60781)(1001, 11.8234)
			};
			\addlegendentry{optimizedVinograd() - нечётный размер}
			
		\end{axis}
	\end{tikzpicture}
	\caption{Зависимость времени выполнения умножения матриц от их размеров в случае нечётных размеров}
	\label{plt:time_odd}
\end{figure}

\newpage
\section{Оценка трудоёмкости}
Для оценки трудоёмкости использовалась следующая модель вычислений: \cite{calc_model}
\begin{itemize}
	\item Трудоёмкость следующих операций единична: +, -, =, +=, -=, ==, !=, <, >, -=, >=, <<, >>, [];
	\item Трудоёмкость следующих операций = 2: *, /, \, \%, /=, *=.
\end{itemize}

Трудоёмкость выбранных алгоритмов сортировок рассчитывалась по написанному коду.

На листинге \ref{lst:mc_std} представлена программа для вычисления трудоёмкости классического алгоритма умножения матриц.

\newpage
\begin{lstinputlisting}[
	caption={Вычисление трудоёмкости классического алгоритма умножения матриц},
	label={lst:mc_std},
	style={c},
	linerange={1-27},
	]{./inc/src/algorithmsCalcs.cpp}
\end{lstinputlisting}

Соответственно получается следующая формула трудоёмоксти:

$FstandartMult = 3+4N+7NM+14NMK$, где N - кол-во строк первой матрицы, M - кол-во столбцов второй матрицы, K - кол-во столбцов первой матрицы

На листингах \ref{lst:mc_vinograd1}-\ref{lst:mc_vinograd2} представлена программа для вычисления трудоёмкости алгоритма Винограда.

\newpage
\begin{lstinputlisting}[
	caption={Вычисление трудоёмкости алгоритма Винограда, часть 1},
	label={lst:mc_vinograd1},
	style={c},
	linerange={29-61},
	]{./inc/src/algorithmsCalcs.cpp}
\end{lstinputlisting}

\newpage
\begin{lstinputlisting}[
	caption={Вычисление трудоёмкости алгоритма Винограда, часть 2},
	label={lst:mc_vinograd1},
	style={c},
	linerange={63-100},
	]{./inc/src/algorithmsCalcs.cpp}
\end{lstinputlisting}

Следовательно формула трудоёмкости будет следующей:

$Fvinograd = 10+10N+6M+19N(K//2)+19M(K//2)+12NM+32NM(K//2)$,  при чётном K
и такой:

$Fvinograd = 12+14N+6M+19N(K//2)+19M(K//2)+28NM+32NM(K//2)$,  при нечётном K.

На листингах \ref{lst:impс_winograd1}-\ref{lst:impс_winograd2} представлена программа для вычисления трудоёмкости оптимизированного алгоритма Винограда.

\begin{lstinputlisting}[
	caption={Вычисление трудоёмкости оптимизированного алгоритма Винограда, часть 1},
	label={lst:impс_winograd1},
	style={c},
	linerange={102-142},
	]{./inc/src/algorithmsCalcs.cpp}
\end{lstinputlisting}

\begin{lstinputlisting}[
	caption={Вычисление трудоёмкости оптимизированного алгоритма Винограда, часть 2},
	label={lst:impс_winograd2},
	style={c},
	linerange={144-172},
	]{./inc/src/algorithmsCalcs.cpp}
\end{lstinputlisting}

Формула трудоёмкости:

$FoptimizedVinograd = 11+9N+5M+12N(K//2)+12M(K//2)+12NM+20MN(K//2)$,  при чётном K,

$FoptimizedVinograd = 12+9N+5M+12N(K//2)+12M(K//2)+23NM+20MN(K//2)$,  при нечётном K.

\section{Вывод}
Были протестированы различные алгоритмы умножения матриц. По итогу иследования выяснилось, что алгоритм Винограда начинает заметно выигравать по времени выполнения у стандартного алгоритма умножения матриц при линейном размере матрицы $\thicksim400$ и больше. Оптимизированный алгоритм Винограда показывает еще более низкие показатели как и при анализе времени выполнения, так и при оценке трудоёмкости, как и ожидалось.
