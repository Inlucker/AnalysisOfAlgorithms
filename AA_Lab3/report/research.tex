\chapter{Исследовательский раздел}
В данном разделе представлены примеры работы программы, сравнительный анализ реализованных алгоритмов и оценка их трудоёмкости.

\section{Примеры работы программы}
На рисунках 4.1-4.3 представлены результаты работы программы для массивов разных длин, заполненных случайными значениями.

\imgsc{h}{1}{N=2}{Результаты сортировки массива с размером = 2}

\imgsc{h}{1}{N=10}{Результаты сортировки массива с размером = 10}

\imgsc{t}{0.9}{N=30}{Результаты сортировки массива с размером = 30}

\newpage
\section{Сравнительный анализ времени выполнения алгоритмов}
Чтобы провести сравнительный анализ времени выполнения алгоритмов замерялось процессорное время для массивов с 100, 200, ... 1000 элементами. Чтобы оценить время выполнения сортировки для массива размера N, он заполнялся цислами от 0 $N^{10}-1$, замерялось процессорное время для части кода, которая сортировала массивы 1000000/N раз, после чего резултат делился на кол-во итераций.

Сравнительный анализ проводилось на компьютере с процессором Intel Core i7-7700K.

Для сортировки пузырьком наихудшим случаем является массив отсортированный в обратном порядке. Наилучшим случаем является полностью отсортированный массив. На рисунке 4.4 изображены зависимости времени выполнения сортировки от длины массива для произвольного, лучшего и худшего случаев. \cite{teoriya}

\begin{figure}
	\begin{tikzpicture}
		\begin{axis}[
			xlabel={Длина массива, кол-во элементов},
			ylabel={Время выполнения, сек.},
			xtick={100,200,300,400,500,600,700,800,900,1000},
			legend pos=north west,
			ymajorgrids=true,
			grid style=dashed,
			width = 400
			]
			
			\addplot[
			color=blue,
			mark=square,
			]
			coordinates {
				(100, 1.40625e-05)(200, 6.25e-05)(300, 0.000140639)(400, 0.00023125)
				(500, 0.000367188)(600, 0.000515831)(700, 0.000689338)
				(800, 0.0008875)(900, 0.00112511)(1000, 0.00139062)
			};
			\addlegendentry{BubbleSort() - произвольный случай}
			
			
			\addplot[
			color=green,
			mark=square,
			]
			coordinates {
				(100, 1.09375e-05)(200, 3.75e-05)(300, 9.37594e-05)(400, 0.0001625)(500, 0.00025)(600, 0.00037515)(700, 0.000492384)(800, 0.0006625)(900, 0.000843834)(1000, 0.00104688)
			};
			\addlegendentry{BubbleSort() - лучший случай}
			
			\addplot[
			color=red,
			mark=square,
			]
			coordinates {
				(100, 1.875e-05)(200, 6.875e-05)(300, 0.000150015)(400, 0.00026875)(500, 0.000414062)(600, 0.00060024)(700, 0.000809699)(800, 0.0010625)(900, 0.00135014)(1000, 0.00165625)
			};
			\addlegendentry{BubbleSort() - худший случай}
			
		\end{axis}
	\end{tikzpicture}
	\caption{Зависимость времени выполнения сортировки пузырьком от длины массива в разных случаях}
\end{figure}

\newpage
Для сортировки выбором наихудшим случаем является массив отсортированный в обратном порядке. Наилучшим случаем является полностью отсортированный массив. На рисунке 4.5 изображены зависимости времени выполнения сортировки от длины массива для произвольного, лучшего и худшего случаев. \cite{teoriya}

\begin{figure}
	\begin{tikzpicture}
		\begin{axis}[
			xlabel={Длина массива, кол-во элементов},
			ylabel={Время выполнения, сек.},
			xtick={100,200,300,400,500,600,700,800,900,1000},
			legend pos=north west,
			ymajorgrids=true,
			grid style=dashed,
			width = 400
			]
			
			\addplot[
			color=blue,
			mark=square,
			]
			coordinates {
				(100, 9.375e-06)(200, 3.125e-05)(300, 6.09436e-05)(400, 0.00010625)
				(500, 0.000164063)(600, 0.00022509)(700, 0.000295431)
				(800, 0.0003875)(900, 0.000492237)(1000, 0.000578125)
			};
			\addlegendentry{SelectionSort() - произвольный случай}
			
			
			\addplot[
			color=green,
			mark=square,
			]
			coordinates {
				(100, 6.25e-06)(200, 2.5e-05)(300, 5.15677e-05)(400, 8.75e-05)(500, 0.000140625)(600, 0.000206333)(700, 0.000262605)(800, 0.00035)(900, 0.000450045)(1000, 0.000546875)
			};
			\addlegendentry{SelectionSort() - лучший случай}
			
			\addplot[
			color=red,
			mark=square,
			]
			coordinates {
				(100, 7.8125e-06)(200, 3.4375e-05)(300, 7.03195e-05)(400, 0.00011875)(500, 0.0001875)(600, 0.000262605)(700, 0.000361082)(800, 0.000475)(900, 0.000590684)(1000, 0.000734375)
			};
			\addlegendentry{SelectionSort() - худший случай}
			
		\end{axis}
	\end{tikzpicture}
	\caption{Зависимость времени выполнения сортировки выбором от длины массива в разных случаях}
\end{figure}

\newpage
Для сортировки вставками наихудшим случаем является массив отсортированный в обратном порядке. Наилучшим случаем является полностью отсортированный массив. На рисунке 4.6 изображены зависимости времени выполнения сортировки от длины массива для произвольного, лучшего и худшего случаев. \cite{teoriya}

\begin{figure}
	\begin{tikzpicture}
		\begin{axis}[
			xlabel={Длина массива, кол-во элементов},
			ylabel={Время выполнения, сек.},
			xtick={100,200,300,400,500,600,700,800,900,1000},
			legend pos=north west,
			ymajorgrids=true,
			grid style=dashed,
			width = 400
			]
			
			\addplot[
			color=blue,
			mark=square,
			]
			coordinates {
				(100, 9.375e-06)(200, 3.4375e-05)(300, 7.50075e-05)(400, 0.0001375)
				(500, 0.00021875)(600, 0.000290741)(700, 0.000404849)
				(800, 0.0005125)(900, 0.00064694)(1000, 0.000796875)
			};
			\addlegendentry{InsertionSort() - произвольный случай}
			
			
			\addplot[
			color=green,
			mark=square,
			]
			coordinates {
				(100, 3.4375e-07)(200, 6.25e-07)(300, 9.37501e-07)(400, 1.1875e-06)(500, 1.48438e-06)(600, 1.78126e-06)(700, 2.1875e-06)(800, 2.375e-06)(900, 2.8125e-06)(1000, 3.125e-06)
			};
			\addlegendentry{InsertionSort() - лучший случай}
			
			\addplot[
			color=red,
			mark=square,
			]
			coordinates {
				(100, 1.71875e-05)(200, 6.875e-05)(300, 0.000173455)(400, 0.0002625)(500, 0.000398437)(600, 0.000562725)(700, 0.000776873)(800, 0.0010125)(900, 0.00126575)(1000, 0.00159375)
			};
			\addlegendentry{InsertionSort() - худший случай}
			
		\end{axis}
	\end{tikzpicture}
	\caption{Зависимость времени выполнения сортировки выбором от длины массива в разных случаях}
\end{figure}

\newpage
Также приведены графики (рисунки 4.7-4.9) для сравнения алгоритмов сортировок между собой в произвольном, лучшем и худшем случаях.

\begin{figure}
	\begin{tikzpicture}
		\begin{axis}[
			xlabel={Длина слов, симв.},
			ylabel={Время выполнения, сек.},
			xtick={100,200,300,400,500,600,700,800,900,1000},
			legend pos=north west,
			ymajorgrids=true,
			grid style=dashed,
			width = 400
			]
			
			\addplot[
			color=blue,
			mark=square,
			]
			coordinates {
				(100, 1.40625e-05)(200, 6.25e-05)(300, 0.000140639)(400, 0.00023125)
				(500, 0.000367188)(600, 0.000515831)(700, 0.000689338)
				(800, 0.0008875)(900, 0.00112511)(1000, 0.00139062)
			};
			\addlegendentry{BubbleSort() - произвольный случай}
			
			
			\addplot[
			color=red,
			mark=square,
			]
			coordinates {
				(100, 9.375e-06)(200, 3.125e-05)(300, 6.09436e-05)(400, 0.00010625)
				(500, 0.000164063)(600, 0.00022509)(700, 0.000295431)
				(800, 0.0003875)(900, 0.000492237)(1000, 0.000578125)
			};
			\addlegendentry{SelectionSort() - произвольный случай}
			
			\addplot[
			color=green,
			mark=square,
			]
			coordinates {
				(100, 9.375e-06)(200, 3.4375e-05)(300, 7.50075e-05)(400, 0.0001375)
				(500, 0.00021875)(600, 0.000290741)(700, 0.000404849)
				(800, 0.0005125)(900, 0.00064694)(1000, 0.000796875)
			};
			\addlegendentry{InsertionSort() - произвольный случай}
			
		\end{axis}
	\end{tikzpicture}
	\caption{Зависимость времени выполнения алгоритмов сортировок от длины массива в произвольном случае}
\end{figure}

\begin{figure}
	\begin{tikzpicture}
		\begin{axis}[
			xlabel={Длина слов, симв.},
			ylabel={Время выполнения, сек.},
			xtick={100,200,300,400,500,600,700,800,900,1000},
			legend pos=north west,
			ymajorgrids=true,
			grid style=dashed,
			width = 400
			]
			
			\addplot[
			color=blue,
			mark=square,
			]
			coordinates {
				(100, 1.09375e-05)(200, 3.75e-05)(300, 9.37594e-05)(400, 0.0001625)(500, 0.00025)(600, 0.00037515)(700, 0.000492384)(800, 0.0006625)(900, 0.000843834)(1000, 0.00104688)
			};
			\addlegendentry{BubbleSort() - лучший случай}
			
			
			\addplot[
			color=red,
			mark=square,
			]
			coordinates {
				(100, 6.25e-06)(200, 2.5e-05)(300, 5.15677e-05)(400, 8.75e-05)(500, 0.000140625)(600, 0.000206333)(700, 0.000262605)(800, 0.00035)(900, 0.000450045)(1000, 0.000546875)
			};
			\addlegendentry{SelectionSort() - лучший случай}
			
			\addplot[
			color=green,
			mark=square,
			]
			coordinates {
				(100, 3.4375e-07)(200, 6.25e-07)(300, 9.37501e-07)(400, 1.1875e-06)(500, 1.48438e-06)(600, 1.78126e-06)(700, 2.1875e-06)(800, 2.375e-06)(900, 2.8125e-06)(1000, 3.125e-06)
			};
			\addlegendentry{InsertionSort() - лучший случай}
			
		\end{axis}
	\end{tikzpicture}
	\caption{Зависимость времени выполнения алгоритмов сортировок от длины массива в лучшем случае}
\end{figure}

\begin{figure}
	\begin{tikzpicture}
		\begin{axis}[
			xlabel={Длина слов, симв.},
			ylabel={Время выполнения, сек.},
			xtick={100,200,300,400,500,600,700,800,900,1000},
			legend pos=north west,
			ymajorgrids=true,
			grid style=dashed,
			width = 400
			]
			
			\addplot[
			color=blue,
			mark=square,
			]
			coordinates {
				(100, 1.875e-05)(200, 6.875e-05)(300, 0.000150015)(400, 0.00026875)(500, 0.000414062)(600, 0.00060024)(700, 0.000809699)(800, 0.0010625)(900, 0.00135014)(1000, 0.00165625)
			};
			\addlegendentry{BubbleSort() - худший случай}
			
			
			\addplot[
			color=red,
			mark=square,
			]
			coordinates {
				(100, 7.8125e-06)(200, 3.4375e-05)(300, 7.03195e-05)(400, 0.00011875)(500, 0.0001875)(600, 0.000262605)(700, 0.000361082)(800, 0.000475)(900, 0.000590684)(1000, 0.000734375)
			};
			\addlegendentry{SelectionSort() - худший случай}
			
			\addplot[
			color=green,
			mark=square,
			]
			coordinates {
				(100, 1.71875e-05)(200, 6.875e-05)(300, 0.000173455)(400, 0.0002625)(500, 0.000398437)(600, 0.000562725)(700, 0.000776873)(800, 0.0010125)(900, 0.00126575)(1000, 0.00159375)
			};
			\addlegendentry{InsertionSort() - худший случай}
			
		\end{axis}
	\end{tikzpicture}
	\caption{Зависимость времени выполнения алгоритмов сортировок от длины массива в худшем случае}
\end{figure}

\newpage
\section{Оценка трудоёмкости}
Для оценки трудоёмкости использовалась следующая модель вычислений:
\begin{itemize}
	\item Трудоёмкость следующих операций единична: +, -, =, +=, -=, ==, !=, <, >, -=, >=, <<, >>, [];
	\item Трудоёмкость следующих операций = 2: *, /, \, \%, /=, *=.
\end{itemize}

Трудоёмкость выбранных алгоритмов сортировок рассчитывалась по написанному коду.

На листинге 4.1 представлена программа для вычисления трудоёмкости алгоритма сортировки пузырьком для худшего случая.

\begin{lstlisting}[language=c++, caption=Вычисление трудоёмкости алгоритма сортировки пузырьком]
int getBubbleSort(int *l, int *r)
{
	int rez = 3; //init+srav
	for (int i = 0; i < r-l; i++)
	{
		rez += 3; //init+srav
		for (int *j = l; j < r-i; j++)
		{
			if (*j > *(j+1))
				swap(j, (j+1));
			rez+=5; //telo j
			rez++; //increment
			rez+=2; //srav
		}
		rez++; //increment
		rez+=2; //srav
	}
	return rez;
}
\end{lstlisting}

Соответственно получается следующая формула трудоёмоксти:

$Fbubblesort = 3 + (3*(N-1) + ((N-1)*N/2)*8) + 3*(N-1)$, где N - размер массива

В лучшем же случае, не надо будет менять элементы местами, а значит трудоёмкость тела цикла по j уменьшится на 3 и формула примет вид:

$Fbubble\_sort = 3 + (3*(N-1) + ((N-1)*N/2)*5) + 3*(N-1)$

\newpage
На листинге 4.2 представлена программа для вычисления трудоёмкости алгоритма сортировки выбором для худшего случая.

\begin{lstlisting}[language=c++, caption=Вычисление трудоёмкости алгоритма сортировки выбором]
int getSelectionSort(int *l, int *r)
{
	int rez = 2; //init+srav
	for (int *i = l; i <= r; i++)
	{
		rez += 2; //double = (assignment)
		int minz = *i, *ind = i;
		rez += 3; //init+srav
		for (int *j = i + 1; j <= r; j++)
		{
			if (*j < minz)
			{
				minz = *j;
				ind = j;
			}
			rez += 3; //telo j
			rez++; //increment
			rez++; //srav
		}
		rez+=3; //swap
		swap(i, ind);
		rez++; //increment
		rez++; //srav
	}
	return rez;
}
\end{lstlisting}

Следовательно формула трудоёмкости будет следующей:

$Fselection\_sort = 2 + 10*N + ((N-1)*N/2)*5$

А в лучшем случае не будет выполнятся условие if и формула станет такой:

$Fselection\_sort = 2 + 10*N + ((N-1)*N/2)*3$

\newpage
На листинге 4.3 представлена программа для вычисления трудоёмкости алгоритма сортировки вставками для худшего случая.

\begin{lstlisting}[language=c++, caption=Вычисление трудоёмкости алгоритма сортировки вставками]
int getInsertionSort(int* l, int* r)
{
	int rez = 3; //init+srav
	for (int *i = l + 1; i <= r; i++)
	{
		rez++; //assigment
		int* j = i;
		rez+=3; //srav
		while (j > l && *(j - 1) > *j)
		{
			rez+=4; //swap
			swap((j - 1), j);
			j--;
			rez++; //deccrement
			rez+=3; //srav
		}
	}
	return rez;
}
\end{lstlisting}

Формула трудоёмкости:

$Finsertion\_sort = 3 + 4*(N-1) + 8*((N-1)*N/2)$

В лучшем случае полностью пропадает тело цикла while, а значит формула изменится на следующую:

$Finsertion\_sort = 3 + 4*(N-1)$

\section{Вывод}
По итогу иследования выяснилось, что разработанная программа работает верно, то-есть сортирует массивы по возрастанию. Кроме этого, смотря на время выполнения каждого алгоритма, логично сделать вывод, что наиболее быстрым в произвольном случае, является алгоритм сортировки выбором и судя по оценке трудоёмкости, наименее трудоёмким является также алгоритм сортировки выбором.