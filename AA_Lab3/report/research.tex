\chapter{Исследовательский раздел}
В данном разделе представлены примеры работы программы, сравнительный анализ реализованных алгоритмов и оценка их трудоёмкости.

%\section{Результаты тестирования}

\section{Примеры работы программы}
На рисунках 4.1-4.3 представлены результаты работы программы для массивов разных длин, заполненных случайными значениями.

\imgsc{h}{1}{N=2}{Результаты сортировки массива с размером = 2}

\imgsc{h}{1}{N=10}{Результаты сортировки массива с размером = 10}

\imgsc{t}{0.9}{N=30}{Результаты сортировки массива с размером = 30}

\newpage
\section{Сравнительный анализ времени выполнения алгоритмов}
Чтобы провести сравнительный анализ времени выполнения алгоритмов замерялось процессорное время для массивов с 100, 200, ... 1000 элементами. Чтобы оценить время выполнения сортировки для массива размера N, он заполнялся цислами от 0 $N^{10}-1$, замерялось процессорное время для части кода, которая сортировала массивы 500000/N раз, после чего резултат делился на кол-во итераций.

Сравнительный анализ проводилось на компьютере с процессором AMD Ryzen 5 5600H.

Для сортировки пузырьком наихудшим случаем является массив отсортированный в обратном порядке. Наилучшим случаем является полностью отсортированный массив. На рисунке 4.4 изображены зависимости времени выполнения сортировки от длины массива для произвольного, лучшего и худшего случаев. \cite{teoriya}

\begin{figure}
	\begin{tikzpicture}
		\begin{axis}[
			xlabel={Длина массива, кол-во элементов},
			ylabel={Время выполнения, сек.},
			xtick={100,200,300,400,500,600,700,800,900,1000},
			legend pos=north west,
			ymajorgrids=true,
			grid style=dashed,
			width = 400
			]
			
			\addplot[
			color=blue,
			mark=square,
			]
			coordinates {
				(100, 0.00533333)(200, 0.052)(300, 0.094)(400, 0.186667)(500, 0.286667)(600, 0.376)(700, 0.549065)(800, 0.706667)(900, 0.891892)(1000, 1.04)
			};
			\addlegendentry{BubbleSort() - произвольный случай}
			
			
			\addplot[
			color=green,
			mark=square,
			]
			coordinates {
				(100, 0.00533333)(200, 0.0206667)(300, 0.047)(400, 0.084)(500, 0.13)(600, 0.186)(700, 0.257009)(800, 0.290667)(900, 0.423423)(1000, 0.52)	
			};
			\addlegendentry{BubbleSort() - лучший случай}
			
			\addplot[
			color=red,
			mark=square,
			]
			coordinates {
				(100, 0.0156667)(200, 0.0626667)(300, 0.125)(400, 0.249333)(500, 0.34)(600, 0.53)(700, 0.693925)(800, 0.957333)(900, 1.12613)(1000, 1.40667)
			};
			\addlegendentry{BubbleSort() - худший случай}
			
		\end{axis}
	\end{tikzpicture}
	\caption{Зависимость времени выполнения сортировки пузырьком от длины массива в разных случаях}
\end{figure}

\newpage
Для сортировки выбором наихудшим случаем является массив отсортированный в обратном порядке. Наилучшим случаем является полностью отсортированный массив. На рисунке 4.5 изображены зависимости времени выполнения сортировки от длины массива для произвольного, лучшего и худшего случаев. \cite{teoriya}

\begin{figure}
	\begin{tikzpicture}
		\begin{axis}[
			xlabel={Длина массива, кол-во элементов},
			ylabel={Время выполнения, сек.},
			xtick={100,200,300,400,500,600,700,800,900,1000},
			legend pos=north west,
			ymajorgrids=true,
			grid style=dashed,
			width = 400
			]
			
			\addplot[
			color=blue,
			mark=square,
			]
			coordinates {
				(100, 0.0032)(200, 0.0188)(300, 0.0468187)(400, 0.0752)(500, 0.11)(600, 0.168067)(700, 0.196078)(800, 0.3008)(900, 0.394595)(1000, 0.436)
			};
			\addlegendentry{SelectionSort() - произвольный случай}
			
			
			\addplot[
			color=green,
			mark=square,
			]
			coordinates {
				(100, 0.0032)(200, 0.0188)(300, 0.0372149)(400, 0.0632)(500, 0.093)(600, 0.15006)(700, 0.17507)(800, 0.2512)(900, 0.308108)(1000, 0.376)
			};
			\addlegendentry{SelectionSort() - лучший случай}
			
			\addplot[
			color=red,
			mark=square,
			]
			coordinates {
				(100, 0.0062)(200, 0.0252)(300, 0.0468187)(400, 0.0872)(500, 0.141)(600, 0.187275)(700, 0.263305)(800, 0.3248)(900, 0.421622)(1000, 0.5)
			};
			\addlegendentry{SelectionSort() - худший случай}
			
		\end{axis}
	\end{tikzpicture}
	\caption{Зависимость времени выполнения сортировки выбором от длины массива в разных случаях}
\end{figure}

\newpage
Для сортировки вставками наихудшим случаем является массив отсортированный в обратном порядке. Наилучшим случаем является полностью отсортированный массив. На рисунке 4.6 изображены зависимости времени выполнения сортировки от длины массива для произвольного, лучшего и худшего случаев. \cite{teoriya}

\begin{figure}
	\begin{tikzpicture}
		\begin{axis}[
			xlabel={Длина массива, кол-во элементов},
			ylabel={Время выполнения, сек.},
			xtick={100,200,300,400,500,600,700,800,900,1000},
			legend pos=north west,
			ymajorgrids=true,
			grid style=dashed,
			width = 400
			]
			
			\addplot[
			color=blue,
			mark=square,
			]
			coordinates {
				(100, 0.0092)(200, 0.0316)(300, 0.0654262)(400, 0.1128)(500, 0.187)(600, 0.243697)(700, 0.306723)(800, 0.4)(900, 0.563964)(1000, 0.686)
			};
			\addlegendentry{InsertionSort() - произвольный случай}
			
			
			\addplot[
			color=green,
			mark=square,
			]
			coordinates {
				(100, 0.000124)(200, 0.000312)(300, 0.000564002)(400, 0.000496)(500, 0.00079)(600, 0.000744003)(700, 0.00109201)(800, 0.001008)(900, 0.00140401)(1000, 0.00124)
			};
			\addlegendentry{InsertionSort() - лучший случай}
			
			\addplot[
			color=red,
			mark=square,
			]
			coordinates {
				(100, 0.0156)(200, 0.0564)(300, 0.112245)(400, 0.2)(500, 0.328)(600, 0.487395)(700, 0.634454)(800, 0.8256)(900, 1.0973)(1000, 1.344)
			};
			\addlegendentry{InsertionSort() - худший случай}
			
		\end{axis}
	\end{tikzpicture}
	\caption{Зависимость времени выполнения сортировки выбором от длины массива в разных случаях}
\end{figure}

\newpage
Также приведены графики (рисунки 4.7-4.9) для сравнения алгоритмов сортировок между собой в произвольном, лучшем и худшем случаях.

\begin{figure}
	\begin{tikzpicture}
		\begin{axis}[
			xlabel={Длина слов, симв.},
			ylabel={Время выполнения, сек.},
			xtick={100,200,300,400,500,600,700,800,900,1000},
			legend pos=north west,
			ymajorgrids=true,
			grid style=dashed,
			width = 400
			]
			
			\addplot[
			color=blue,
			mark=square,
			]
			coordinates {
				(100, 0.00533333)(200, 0.052)(300, 0.094)(400, 0.186667)(500, 0.286667)(600, 0.376)(700, 0.549065)(800, 0.706667)(900, 0.891892)(1000, 1.04)
			};
			\addlegendentry{BubbleSort() - произвольный случай}
			
			
			\addplot[
			color=red,
			mark=square,
			]
			coordinates {
				(100, 0.0032)(200, 0.0188)(300, 0.0468187)(400, 0.0752)(500, 0.11)(600, 0.168067)(700, 0.196078)(800, 0.3008)(900, 0.394595)(1000, 0.436)
			};
			\addlegendentry{SelectionSort() - произвольный случай}
			
			\addplot[
			color=green,
			mark=square,
			]
			coordinates {
				(100, 0.0092)(200, 0.0316)(300, 0.0654262)(400, 0.1128)(500, 0.187)(600, 0.243697)(700, 0.306723)(800, 0.4)(900, 0.563964)(1000, 0.686)
			};
			\addlegendentry{InsertionSort() - произвольный случай}
			
		\end{axis}
	\end{tikzpicture}
	\caption{Зависимость времени выполнения алгоритмов сортировок от длины массива в произвольном случае}
\end{figure}

\begin{figure}
	\begin{tikzpicture}
		\begin{axis}[
			xlabel={Длина слов, симв.},
			ylabel={Время выполнения, сек.},
			xtick={100,200,300,400,500,600,700,800,900,1000},
			legend pos=north west,
			ymajorgrids=true,
			grid style=dashed,
			width = 400
			]
			
			\addplot[
			color=blue,
			mark=square,
			]
			coordinates {
				(100, 0.00533333)(200, 0.0206667)(300, 0.047)(400, 0.084)(500, 0.13)(600, 0.186)(700, 0.257009)(800, 0.290667)(900, 0.423423)(1000, 0.52)	
			};
			\addlegendentry{BubbleSort() - лучший случай}
			
			
			\addplot[
			color=red,
			mark=square,
			]
			coordinates {
				(100, 0.0032)(200, 0.0188)(300, 0.0372149)(400, 0.0632)(500, 0.093)(600, 0.15006)(700, 0.17507)(800, 0.2512)(900, 0.308108)(1000, 0.376)
			};
			\addlegendentry{SelectionSort() - лучший случай}
			
			\addplot[
			color=green,
			mark=square,
			]
			coordinates {
				(100, 0.000124)(200, 0.000312)(300, 0.000564002)(400, 0.000496)(500, 0.00079)(600, 0.000744003)(700, 0.00109201)(800, 0.001008)(900, 0.00140401)(1000, 0.00124)
			};
			\addlegendentry{InsertionSort() - лучший случай}
			
		\end{axis}
	\end{tikzpicture}
	\caption{Зависимость времени выполнения алгоритмов сортировок от длины массива в лучшем случае}
\end{figure}

\begin{figure}
	\begin{tikzpicture}
		\begin{axis}[
			xlabel={Длина слов, симв.},
			ylabel={Время выполнения, сек.},
			xtick={100,200,300,400,500,600,700,800,900,1000},
			legend pos=north west,
			ymajorgrids=true,
			grid style=dashed,
			width = 400
			]
			
			\addplot[
			color=blue,
			mark=square,
			]
			coordinates {
				(100, 0.0156667)(200, 0.0626667)(300, 0.125)(400, 0.249333)(500, 0.34)(600, 0.53)(700, 0.693925)(800, 0.957333)(900, 1.12613)(1000, 1.40667)
			};
			\addlegendentry{BubbleSort() - худший случай}
			
			
			\addplot[
			color=red,
			mark=square,
			]
			coordinates {
				(100, 0.0062)(200, 0.0252)(300, 0.0468187)(400, 0.0872)(500, 0.141)(600, 0.187275)(700, 0.263305)(800, 0.3248)(900, 0.421622)(1000, 0.5)
			};
			\addlegendentry{SelectionSort() - худший случай}
			
			\addplot[
			color=green,
			mark=square,
			]
			coordinates {
				(100, 0.0156)(200, 0.0564)(300, 0.112245)(400, 0.2)(500, 0.328)(600, 0.487395)(700, 0.634454)(800, 0.8256)(900, 1.0973)(1000, 1.344)
			};
			\addlegendentry{InsertionSort() - худший случай}
			
		\end{axis}
	\end{tikzpicture}
	\caption{Зависимость времени выполнения алгоритмов сортировок от длины массива в худшем случае}
\end{figure}

\newpage
\section{Оценка трудоёмкости}
Для оценки трудоёмкости использовалась следующая модель вычислений: \cite{calc_model}
\begin{itemize}
	\item Трудоёмкость следующих операций единична: +, -, =, +=, -=, ==, !=, <, >, -=, >=, <<, >>, [];
	\item Трудоёмкость следующих операций = 2: *, /, \, \%, /=, *=.
\end{itemize}

Трудоёмкость выбранных алгоритмов сортировок рассчитывалась по написанному коду.

На листинге 4.1 представлена программа для вычисления трудоёмкости алгоритма сортировки пузырьком для худшего случая.

\begin{lstlisting}[language=c++, caption=Вычисление трудоёмкости алгоритма сортировки пузырьком]
int getBubbleSort(int *l, int *r)
{
	int rez = 3; //init+srav
	for (int i = 0; i < r-l; i++)
	{
		rez += 3; //init+srav
		for (int *j = l; j < r-i; j++)
		{
			if (*j > *(j+1))
				swap(j, (j+1));
			rez+=5; //telo j
			rez++; //increment
			rez+=2; //srav
		}
		rez++; //increment
		rez+=2; //srav
	}
	return rez;
}
\end{lstlisting}

Соответственно получается следующая формула трудоёмоксти:

$Fbubblesort = 3 + (3*(N-1) + ((N-1)*N/2)*8) + 3*(N-1)$, где N - размер массива

В лучшем же случае, не надо будет менять элементы местами, а значит трудоёмкость тела цикла по j уменьшится на 3 и формула примет вид:

$Fbubble\_sort = 3 + (3*(N-1) + ((N-1)*N/2)*5) + 3*(N-1)$

\newpage
На листинге 4.2 представлена программа для вычисления трудоёмкости алгоритма сортировки выбором для худшего случая.

\begin{lstlisting}[language=c++, caption=Вычисление трудоёмкости алгоритма сортировки выбором]
int getSelectionSort(int *l, int *r)
{
	int rez = 2; //init+srav
	for (int *i = l; i <= r; i++)
	{
		rez += 2; //double = (assignment)
		int minz = *i, *ind = i;
		rez += 3; //init+srav
		for (int *j = i + 1; j <= r; j++)
		{
			if (*j < minz)
			{
				minz = *j;
				ind = j;
			}
			rez += 3; //telo j
			rez++; //increment
			rez++; //srav
		}
		rez+=3; //swap
		swap(i, ind);
		rez++; //increment
		rez++; //srav
	}
	return rez;
}
\end{lstlisting}

Следовательно формула трудоёмкости будет следующей:

$Fselection\_sort = 2 + 10*N + ((N-1)*N/2)*5$

А в лучшем случае не будет выполнятся условие if и формула станет такой:

$Fselection\_sort = 2 + 10*N + ((N-1)*N/2)*3$

\newpage
На листинге 4.3 представлена программа для вычисления трудоёмкости алгоритма сортировки вставками для худшего случая.

\begin{lstlisting}[language=c++, caption=Вычисление трудоёмкости алгоритма сортировки вставками]
int getInsertionSort(int* l, int* r)
{
	int rez = 3; //init+srav
	for (int *i = l + 1; i <= r; i++)
	{
		rez++; //assigment
		int* j = i;
		rez+=3; //srav
		while (j > l && *(j - 1) > *j)
		{
			rez+=4; //swap
			swap((j - 1), j);
			j--;
			rez++; //deccrement
			rez+=3; //srav
		}
	}
	return rez;
}
\end{lstlisting}

Формула трудоёмкости:

$Finsertion\_sort = 3 + 4*(N-1) + 8*((N-1)*N/2)$

В лучшем случае полностью пропадает тело цикла while, а значит формула изменится на следующую:

$Finsertion\_sort = 3 + 4*(N-1)$

\section{Вывод}
По итогу иследования выяснилось, что разработанная программа работает верно, то-есть сортирует массивы по возрастанию. Кроме этого, смотря на время выполнения каждого алгоритма, логично сделать вывод, что наиболее быстрым в произвольном случае, является алгоритм сортировки выбором и судя по оценке трудоёмкости, наименее трудоёмким является также алгоритм сортировки выбором.